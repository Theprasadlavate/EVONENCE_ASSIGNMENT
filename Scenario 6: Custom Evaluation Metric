import numpy as np
from sklearn.metrics import accuracy_score

def weighted_accuracy(y_true, y_pred, class_weights=None):
   
    if class_weights is None:
        class_weights = {0: 1, 1: 2}  # Default weights

    y_true = np.array(y_true)
    y_pred = np.array(y_pred)

    # Initialize numerator and denominator for weighted accuracy
    weighted_correct = 0
    total_weight = 0

    # Iterate through each class
    for cls, weight in class_weights.items():
        # Find indices of current class
        cls_indices = (y_true == cls)
        # Count correct predictions for this class
        correct = np.sum(y_pred[cls_indices] == y_true[cls_indices])
        # Update weighted numerator
        weighted_correct += weight * correct
        # Update weighted denominator
        total_weight += weight * np.sum(cls_indices)

    return weighted_correct / total_weight


# -----------
# Example usage :-
# -----------
y_true = [0, 0, 1, 1, 1, 0]
y_pred = [0, 1, 1, 0, 1, 0]

score = weighted_accuracy(y_true, y_pred)
print("Weighted Accuracy:", score)


 """
    Computes a weighted accuracy score.

    Each class can be assigned a weight, and the accuracy is
    calculated by giving more importance to classes with higher weight.

    Args:
        y_true (array-like): True class labels.
        y_pred (array-like): Predicted class labels.
        class_weights (dict, optional): Dictionary mapping class label to weight.
                                        Example: {0:1, 1:2}

    Returns:
        float: Weighted accuracy score between 0 and 1.
    """
